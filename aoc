#!/usr/bin/python3

import os
import time
import argparse
import threading
import subprocess
from dataclasses import dataclass

import requests


CACHE_FILENAME = '.cache/{}_{}_input.txt'

SPECIAL_INPUTS = set((
    (2015, 4),
    (2015, 10),
    (2015, 11),
    (2015, 20),
    (2019, 4),
))


class ReturnValueThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.return_value = None

    def run(self):
        """
        Copied verbatim from the threading module, plus the added return_value.
        """
        try:
            if self._target:
                self.return_value = self._target(*self._args, **self._kwargs)
        finally:
            # Avoid a refcycle if the thread is running a function with
            # an argument that has a member that points to the thread.
            del self._target, self._args, self._kwargs


@dataclass
class ProcStats:
    pid: int
    utime: int  # time scheduled in user mode (in clock ticks)
    stime: int  # time scheduled in kernel mode (in clock ticks)
    num_threads: int
    starttime: int  # time process started (since boot, in clock ticks)
    vsize: int  # virtual memory size
    rss: int  # resident set size
    processor: int
    size: int  # total program size
    resident: int  # resident set size
    uptime: float  # time since last boot

    @property
    def _clk_tck(self):
        return os.sysconf(os.sysconf_names['SC_CLK_TCK'])

    @property
    def utime_seconds(self):
        return self.utime / self._clk_tck

    @property
    def stime_seconds(self):
        return self.stime / self._clk_tck

    @property
    def starttime_seconds(self):
        return self.starttime / self._clk_tck

    @property
    def runtime(self):
        return self.uptime - self.starttime_seconds


def parse_args():
    parser = argparse.ArgumentParser(
        description="""
Download or take from a cache the input for an AoC problem, then
run the solution with this input and present the result; along with
stats about the process. If it takes long enough the stats will keep
updating. The solution is expected to be a single executable file in a
directory named after the year in the working directory, with its name
as the day, and that takes the problem(1 for part 1, 2 for part 2) as
its argument.""".strip(),
        epilog="""
A file called session.txt must exist within the working directory
when this script is executed. A new directory called .cache may be
created also on the working directory.  """.strip()
    )

    parser.add_argument(
        '--debug',
        action='store_true',
        help="""Add this argument to run the debug verison. No statistics are
printed.""".strip()
    )
    parser.add_argument(
        '--input',
        action='store_true',
        help="""Add this argument to manually enter an input string""".strip()
    )

    parser.add_argument(
        'year',
        type=int,
        help="""Year of the problem"""
    )
    parser.add_argument(
        'day',
        type=int,
        help="""Day of the problem"""
    )
    parser.add_argument(
        'problem',
        type=int,
        help="""Part of the problem (1 or 2)"""
    )

    return parser.parse_args()


def get_input(year: int, day: int, manual_input: bool) -> str:
    if manual_input:
        return input()

    inputstr = get_input_from_cache(year, day)
    if inputstr is None:
        inputstr = get_input_from_aoc(year, day)
        if inputstr is not None:
            save_input_to_cache(year, day, inputstr)
    return inputstr


def get_input_from_cache(year: int, day: int) -> str:
    filename = CACHE_FILENAME.format(year, day)
    try:
        with open(filename, 'r') as f:
            return f.read()
    except IOError:
        return None


def get_session() -> str:
    with open('session.txt') as f:
        return f.read().strip()


def get_filename(year: int, day: int, debug: bool) -> str:
    return '{}/{}{}'.format(year, day, '_dbg' if debug else '_rel')


def get_input_from_aoc(year: int, day: int) -> str:
    if (year, day) in SPECIAL_INPUTS:
        print("The input for day {}, year {} is not a file, it's a text "
              "string in the problem description."
              .format(day, year))
        return input("Enter the input here (it will be cached): ")

    url = "https://adventofcode.com/{}/day/{}/input".format(year, day)
    cookies = {'session': get_session()}
    r = requests.get(url, cookies=cookies)
    r.raise_for_status()
    return r.text


def save_input_to_cache(year: int, day: int, input: str):
    os.makedirs('.cache', exist_ok=True)
    filename = CACHE_FILENAME.format(year, day)
    with open(filename, 'w') as f:
        f.write(input)


def launch_solution(year: int, day: int, problem: int,
                    debug: bool, input: str):
    def communicate_thread(process, input):
        output, _ = process.communicate(input.encode('ascii'))
        return output.decode('ascii')

    process_name = get_filename(year, day, debug)
    process = subprocess.Popen(
        [process_name, str(problem)],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE
    )

    thread = ReturnValueThread(
        target=communicate_thread,
        args=(process, input)
    )

    return thread, process.pid


def show_result(thread):
    thread.join()
    print("Result: {}".format(str(thread.return_value).strip()))


def show_results_only(thread, pid):
    thread.start()
    show_result(thread)


def show_stats_loop(thread, pid):
    t = time.perf_counter()
    thread.start()
    print_process_stats(pid, clear=False)

    while thread.is_alive():
        time.sleep(0.1)
        print_process_stats(pid)

    print()
    print("Time: {:.5f}".format((time.perf_counter() - t)))
    show_result(thread)


def print_process_stats(pid, clear=True):
    stats = get_process_stats(pid)
    if stats is not None:
        if clear:
            clear_process_stats()
        s = """
PID:                  {}
User mode time (s):   {:.5f}
Kernel mode time (s): {:.5f}
Threads:              {}
Size:                 {}
Runtime (s):          {:.5f}
""".strip()
        s = '\n'.join(l + '\033[K' for l in s.splitlines())
        s = s.format(stats.pid, stats.utime_seconds, stats.stime_seconds,
                     stats.num_threads, stats.size, stats.runtime)
        print(s)


def clear_process_stats():
    print(''.join(['\033[F']*6), end='')


def get_process_stats(pid):
    try:
        with open('/proc/{}/stat'.format(pid)) as f:
            stats_str = f.read()
    except IOError:
        return None

    stats_split = stats_str.split()
    _, comm, state, ppid, pgrp, session, tty_nr, tpgid, flags, minflt,\
        cminflt, majflt, cmajflt, utime, stime, cutime, cstime, priority,\
        nice, num_threads, itrealvalue, starttime, vsize, rss, rsslim,\
        startcode, endcode, startstack, kstkesp, kstkeip, signal, blocked,\
        sigignore, sigcatch, wchan, nswap, cnswap, exit_signal, processor,\
        rt_priority, policy, delayacct_blkio_ticks, guest_time, cguest_time,\
        start_data, end_data, start_brk, arg_start, arg_end, env_start,\
        env_end, exit_code = stats_split

    try:
        with open('/proc/{}/statm'.format(pid)) as f:
            stats_str = f.read()
    except IOError:
        return None

    stats_split = stats_str.split()
    size, resident, shared, text, lib, data, dt = stats_split

    try:
        with open('/proc/uptime') as f:
            stats_str = f.read()
    except IOError:
        return None

    stats_split = stats_str.split()
    uptime, idletime = stats_split

    return ProcStats(int(pid), int(utime), int(stime), int(num_threads),
                     int(starttime), int(vsize), int(rss), int(processor),
                     int(size), int(resident), float(uptime))


def prepare_solution(year, day, debug):
    subprocess.run(['make', get_filename(year, day, debug)])


def unprepare_solution(year, day, debug):
    subprocess.run(['rm', get_filename(year, day, debug)])


def main():
    args = parse_args()

    input = get_input(args.year, args.day, args.input)
    prepare_solution(args.year, args.day, args.debug)
    thread, pid = launch_solution(args.year, args.day, args.problem,
                                  args.debug, input)

    try:
        if args.debug:
            show_results_only(thread, pid)
        else:
            show_stats_loop(thread, pid)
    finally:
        unprepare_solution(args.year, args.day, args.debug)


if __name__ == "__main__":
    main()
